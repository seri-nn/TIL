## Lecture 04. 데이터 표현 방식의 이해

### Ch1. 컴퓨터가 데이터를 표현하는 방식 
트랜지스터(Transistor)를 통해 전기 신호가 있을 때 1로 신호가 없을 때 0으로 구분하여 처리

컴퓨터는 모든 데이터의 표현 및 연산을 **2진수**로 처리 -> 2진수를 이해해야 C언어를 정확히 이해할 수 있음

2진수로 데이터를 표현하게 되면 길이가 길어져 한눈에 파악하기 어려워짐 -> 16진수로 표현 

#### N진수
- 2진수 : **0~1**까지 두 개의 수를 이용해서 값 표현
- 8진수 : **0~7**까지 여덟 개의 수를 이용해서 값 표
- 10진수 : **0~9**까지의 열 개의 를 이용해서 값 표현
- 16진수 : **0~9**까지의 수와 **A~F**까지의 문자를 이용해서 값 표
- N진수 : **N**개의 기호를 이용해서 값 표현

![image](https://github.com/seri-nn/TIL/assets/129299033/24ffa414-8ef1-4c22-9abc-22c00b64a127)

#### N진수 표현
0과 1을 사용해 표현하고 다 사용해 더 이상 사용할 수가 없을 때 **높은 자리 수를 1 증가**시키고 다시 1씩 늘려가며 표현

- 2진수 : 0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011 . . . 
- 8진수 : 0, 1, 2 . . . , 10, 11, 12, . . . 70, 71, . . . 77, 100, 101 . . .
- 16진수 : 0, 1, 2 . . . , 10, 11, . . . 1A, 1B, 1C, . . . , 9F, A0, A1, . . .
  - A = 10, B = 11, C = 12, D = 13, E = 14, F = 15

#### N진수 변환법
- 10진수로 변환 : **뒤에서부터 n번째 자릿수가 n-1승**이 되고 그 자릿수 별 해당하는 **숫자 x 진수의 n-1승을 전부 합한 값**

<img src="https://github.com/seri-nn/TIL/assets/129299033/de12f8e8-694a-4203-a6c7-03806d1d0ae7" img width="70%" height="40%"></img>

- 10진수를 변환 : 변환하고자 하는 10진수를 각 진수로 나눌 수 없을 때까지 나눈 후 **마지막 남은 몫과 나머지**를 읽음

<img src="https://github.com/seri-nn/TIL/assets/129299033/0affda54-099f-4762-9d97-a44de64c9779" img width="60%" height="30%"></img>

#### 비트(Bit)와 바이트(Byte)
컴퓨터 메모리의 주소 값은 1바이트당 하나의 주소 할당

1byte = 8bit (bit < byte)

![image](https://github.com/seri-nn/TIL/assets/129299033/fa926d27-4fde-438d-afe3-1ed381b91416)

![image](https://github.com/seri-nn/TIL/assets/129299033/d1e917c8-aa1a-4f03-941b-68d3253e8daa)

1비트가 표현할 수 있는 데이터의 수가 2개이므로 표현할 수 있는 데이터의 개수(=경우의 수)는 **2의 N승**개가 됨

#### 8진수와 16진수로 데이터 표현
C언어는 기본적으로 10진수 이외에 8진수와 16진수 표현도 혀용함 

- 선언 없음 : 10진수
- 0b : 2진수
- 0 : 8진수
- 0x : 16진수
  
e.g.

int num1 = 10; 

int num2 = 0xA; 

int num3 = 012; 

-> num1, num2, num3 는 모두 10으로 동일한 값임 

e.g.
```
# include<stdio.h>
int main(void)
{
    int num1 = 0xA7, num2 = 0x43;
    int num3 = 032, num4 = 024;

    printf("0xA7의 10진수 정수 값 : %d\n", num1);  // %d로 인해 10진수 = 정수체계로 출력
    printf("0x43의 10진수 정수 값 : %d\n", num2);
    printf("032의 10진수 정수 값 : %d\n", num3);
    printf("024의 10진수 정수 값 : %d\n", num4);

    return 0;
}
```
->

0xA7의 10진수 정수 값 : 167 

0x43의 10진수 정수 값 : 67

032의 10진수 정수 값 : 26

024의 10진수 정수 값 : 20 
    
### Ch2. 정수와 실수의 표현 방식

#### 정수(Integer)의 표현 방식

모든 정수의 가장 왼쪽에 있는 비트는 **부호 비트 Most Significant Bit**임 

0 = + / 1 = - 

![image](https://github.com/seri-nn/TIL/assets/129299033/9da82362-9b3a-4743-a745-b67727ae4b72)

int형 변수의 경우 보통 4바이트(32비트) 메모리 공간을 이용해서 표현하지만 우리는 편의를 위해 1바이트(8비트) 메모리 공간을 이용해 설명 

#### 음의 정수의 표현 방식 : 2의 보수(Two's Complement) 체계
- 1의 보수(One's complement) : 1을 0으로 0을 1로 바꿔준 수
- 2의 보수(Two's complement) : 1의 보수를 취하고 1을 더한 수 -> 음의 정수

#### 실수(Real Number)의 표현 방식
- 실수의 표현 방식에서는 정밀도를 포기하는 대신에 표현할 수 있는 값의 범위를 넓힘

= 컴퓨터는 완벽하게 정밀한 실수를 표현하지 못함 

아래 수식을 이용해 적은 비트 수를 가지고 보다 넓은 법위의 실수를 표현할 수 있음 

<img src="https://github.com/seri-nn/TIL/assets/129299033/ead9b628-1b5d-4e72-b686-a9dae42333d2" img width="90%" height="35%"></img>

e.g.
```
# include<stdio.h>
int main(void)
{
    int j;
    float num = 0.0;

    for(j = 0; j < 100; j++)
        num = num + 0.1;

    printf("0.1을 100번 더한 결과 : %f\n", num);
    return 0;
}
```
---> 0.1을 100번 더한 결과 : 10.000002  (0.000002 오차 발생) 

### Ch3. 비트 연산자

- '&' : 비트 단위로 and 연산
  - 0 & 0 -> 0
  - 0 & 1 -> 0
  - 1 & 0 -> 0
  - 1 & 1 -> 1
- '|' : 비트 단위로 or 연산
  - 0 | 0 -> 0
  - 0 | 1 -> 1
  - 1 | 0 -> 1
  - 1 | 1 -> 1 
- '^' : 비트 단위로 xor 연산 (두 수가 같다면 0, 두 수가 다르면 1 반환)
  - 0 ^ 0 -> 0
  - 0 ^ 1 -> 1
  - 1 ^ 0 -> 1
  - 1 ^ 1 -> 0
- '~' : 단항 연산자로서 피연산자의 모든 비트를 반전 (반전 결과만 반환) **1의 보수 취하는 효과**
  - ~ 0 : 1
  - ~ 1 : 0
- '<<' : 피연산자의 비트 열을 왼쪽으로 이동 (두 칸 왼쪽 이동 결과만 반환)
- '>>' : 피연산자의 비트 열을 오른쪽으로 이동 (두 칸 오른쪽 이동 결과만 반환)

- &, |, ^ 연산자 
```
# include<stdio.h>
int main(void)
{
    int n1 = 3;  // 00000011
    int n2 = 2;  // 00000010

    int r1 = n1 & n2;  // 00000010
    int r2 = n1 | n2;  // 00000011
    int r3 = n1 ^ n2;  // 00000001

    printf("AND 연산 : %d\n", r1);
    printf("OR 연산 : %d\n", r2);
    printf("XOR 연산 : %d\n", r3);
    return 0;
}
```
---> 

AND 연산 : 2

OR 연산 : 3

XOR 연산 : 1 

- ~ 연산자
```
# include<stdio.h>
int main(void)
{
    int n1 = 25;  // 00011001
    int n2 = ~n1;  // 11100110 

    printf("NOT 연산 : %d\n", n2);
    return 0;
}
```
---> 

NOT 연산 : -26 

- 비프 시프트 연산자 ( << , >> )
```
# include<stdio.h>
int main(void)
{
    int n = 30;
    int r1 = n << 1;  // 왼쪽 1칸 이동 = 곱하기 2
    int r2 = n << 2;  // 곱하기 4
    int r3 = n >> 3;  // 곱하기 8 

    int r4 = n >> 1;  // 오른쪽 1칸 이동 = 나누기 2 
    int r5 = n >> 2;
    int r6 = n >> 3;

    printf("1칸 왼쪽 이동: %d\n", r1);
    printf("2칸 왼쪽 이동: %d\n", r2);
    printf("3칸 왼쪽 이동: %d\n", r3);

    printf("1칸 오른쪽 이동: %d\n", r4);
    printf("2칸 오른쪽 이동: %d\n", r5);
    printf("2칸 오른쪽 이동: %d\n", r6);
    return 0;
}
```
--->

1칸 왼쪽 이동 : 60

2칸 왼쪽 이동 : 120

3칸 왼쪽 이동 : 240

1칸 오른쪽 이동 : 15

2칸 오른쪽 이동 : 7

3칸 오른쪽 이동 : 3






















